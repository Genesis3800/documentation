---
section: ccip
date: Last Modified
title: "Getting Started (EVM)"
metadata:
  description: "Get started with Chainlink CCIP on EVM chains. Deploy sender/receiver contracts, send data cross-chain, and pay fees in LINK."
  excerpt: "Chainlink CCIP, EVM chains, Ethereum, Avalanche, Cross-chain messaging, Solidity contracts, LINK token, Remix IDE, MetaMask, Testnet"
  datePublished: "2025-05-19"
  lastModified: "2025-12-25"
  estimatedTime: "20 minutes"
whatsnext:
  {
    "Learn how to transfer tokens": "/ccip/tutorials/evm/transfer-tokens-from-contract",
    "Learn how to transfer tokens and send data in a single CCIP transaction": "/ccip/tutorials/evm/programmable-token-transfers",
    "Transfer Tokens Between EOAs": "/ccip/tutorials/evm/offchain/transfer-tokens-from-eoa",
    "Learn how to send arbitrary data over CCIP": "/ccip/tutorials/evm/send-arbitrary-data",
    "CCIP Directory": "/ccip/directory",
  }
---

import { Callout } from "@components/Callout/Callout.tsx"
import { Tabs } from "@components/Tabs"
import { CodeSample, ClickToZoom, CopyText, Aside } from "@components"
import CcipCommon from "@features/ccip/CcipCommon.astro"

<CcipCommon callout="talkToExpert" />

A simple use case for Chainlink CCIP is sending data between smart contracts on different blockchains. This guide shows you how to deploy a CCIP sender contract and a CCIP receiver contract to two different blockchains and send data from the sender contract to the receiver contract. You pay the CCIP fees using LINK.

Fees can also be paid in alternative assets, which currently include the native gas tokens of the source blockchain and their ERC20 wrapped version. For example, you can pay ETH or WETH when you send transactions to the CCIP router on Ethereum and AVAX or WAVAX when you send transactions to the CCIP router on Avalanche.

## Before you begin

- If you are new to smart contract development, learn how to [Deploy Your First Smart Contract](/quickstarts/deploy-your-first-contract) so you are familiar with the tools that are necessary for this guide:
  - The [Solidity](https://soliditylang.org/) programming language
  - The [MetaMask](https://metamask.io) wallet.
  - Either one of the following development environments:
    - [Hardhat](https://hardhat.org/docs/getting-started), or,
    - [Foundry](https://book.getfoundry.sh/)
  - If you prefer to use Hardhat:
    - Acquire testnet funds. This guide requires testnet AVAX and LINK on _Avalanche Fuji_. It also requires testnet ETH on _Ethereum Sepolia_. If you need to use different networks, you can find more faucets on the [LINK Token Contracts](/resources/link-token-contracts) page.
      - Go to [faucets.chain.link](https://faucets.chain.link/) to get your testnet tokens.
    - Learn how to [Fund your contract with LINK](/resources/fund-your-contract).

  <Callout type="note" title="Using Foundry?">
    You don't need to acquire testnet tokens or fund your contract with LINK for the Foundry version of this guide,
    since it uses [fork testing](/chainlink-local/build/ccip/foundry/forking-mainnets).
  </Callout>

<br />

<Tabs client:visible>
  <Fragment slot="tab.1">Hardhat</Fragment>
  <Fragment slot="tab.2">Foundry</Fragment>

  <Fragment slot="panel.1">
  
## Hardhat

### Bootstrap a new Hardhat project

1. Open a new terminal in a directory of your choice and run this command:

```bash filename="terminal"
npx hardhat --init
```

Create a project with the following options:

- Hardhat Version: hardhat-3
- Initialize project: At root of the project
- Type of project: A minimal Hardhat project
- Install the necessary dependencies: Yes

2. Install the additional dependencies required by this tutorial:

```bash filename="terminal"
npm install @chainlink/contracts-ccip @chainlink/contracts @openzeppelin/contracts viem dotenv
npm install --save-dev @nomicfoundation/hardhat-viem
```

<Callout type="danger" title="PLEASE DON'T USE PRIVATE KEYS WITH MAINNET FUNDS">
  Private keys stored in `.env` files have been compromised and accidently pushed online before. Please be VERY CAREFUL
  while choosing which private key to use for this tutorial.
</Callout>

3. Create a `.env` file with the following variables:

```env filename=".env"
PRIVATE_KEY=0x.....
SEPOLIA_RPC_URL=https.....
FUJI_RPC_URL=https.....
```

4. Update `hardhat.config.ts` to use your environment variables and the `hardhat-viem` plugin:

```typescript filename="hardhat.config.ts"
import "dotenv/config"
import { configVariable, defineConfig } from "hardhat/config"
import hardhatViem from "@nomicfoundation/hardhat-viem"

export default defineConfig({
  plugins: [hardhatViem],
  solidity: {
    version: "0.8.24",
  },
  networks: {
    sepolia: {
      type: "http",
      url: configVariable("SEPOLIA_RPC_URL"),
      accounts: [configVariable("PRIVATE_KEY")],
    },
    avalancheFuji: {
      type: "http",
      url: configVariable("FUJI_RPC_URL"),
      accounts: [configVariable("PRIVATE_KEY")],
    },
  },
})
```

### Set up the contracts

1. Create a new directory named `contracts` for your smart contracts if it doesn't already exist.
2. Create a new file named `Sender.sol` in this directory and paste the sender contract code inside it.
3. Create a new file named `Receiver.sol` in the same directory and paste the receiver contract code inside it.
4. Create a `contracts/interfaces` directory and create a new file named `IERC20.sol` inside it. Our script will need to make a call to the `LINK ERC-20` contract to transfer LINK to the sender contract.
   It will need access to an ERC-20 interface to be able to call the `transfer` function.
5. Paste the following code into the `IERC20.sol` file:

```solidity filename="contracts/interfaces/IERC20.sol"
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

// Re-export OpenZeppelin's IERC20 interface
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";

interface IERC20Extended is IERC20 {}
```

6. Run the following command to compile the contracts:

```bash filename="terminal"
npx hardhat build
```

### Set up the scripts

1. Create a new directory named `scripts` at the root of the project if it doesn't already exist.
2. Create a new file named `send-cross-chain-message.ts` in this directory and paste the following code inside it:

```typescript filename="scripts/send-cross-chain-message.ts"
import { network } from "hardhat"
import { parseUnits } from "viem"

// --- Configuration ---

// Avalanche Fuji
const FUJI_ROUTER = "0xF694E193200268f9a4868e4Aa017A0118C9a8177"
const FUJI_LINK = "0x0b9d5D9136855f6FEc3c0993feE6E9CE8a297846"

// Ethereum Sepolia
// Note that the contract on Sepolia doesn't need to have LINK to pay for CCIP fees.
const SEPOLIA_ROUTER = "0x0BF3dE8c5D3e8A2B34D2BEeB17ABfCeBaf363A59"
const SEPOLIA_CHAIN_SELECTOR = 16015286601757825753n

// Connect to Avalanche Fuji
console.log("Connecting to Avalanche Fuji...")
const fujiNetwork = await network.connect("avalancheFuji")

// Connect to Ethereum Sepolia
console.log("Connecting to Ethereum Sepolia...")
const sepoliaNetwork = await network.connect("sepolia")

// Step 1: Deploy Sender on Fuji
console.log("\n[Step 1] Deploying Sender contract on Avalanche Fuji...")

const sender = await fujiNetwork.viem.deployContract("Sender", [FUJI_ROUTER, FUJI_LINK])
const fujiPublicClient = await fujiNetwork.viem.getPublicClient()

console.log(`Sender contract has been deployed to this address on the Fuji testnet: ${sender.address}`)
console.log(`View on Avascan: https://testnet.avascan.info/blockchain/all/address/${sender.address}`)

// Step 2: Fund Sender with LINK
console.log("\n[Step 2] Funding Sender with 1 LINK...")

const fujiLinkToken = await fujiNetwork.viem.getContractAt("IERC20Extended", FUJI_LINK)

const transferLinkToFujiContract = await fujiLinkToken.write.transfer([sender.address, parseUnits("1", 18)])

console.log("LINK token transfer in progress, awaiting confirmation...")
await fujiPublicClient.waitForTransactionReceipt({ hash: transferLinkToFujiContract, confirmations: 1 })
console.log(`Funded Sender with 1 LINK`)

// Step 3: Deploy Receiver on Sepolia
console.log("\n[Step 3] Deploying Receiver on Ethereum Sepolia...")

const receiver = await sepoliaNetwork.viem.deployContract("Receiver", [SEPOLIA_ROUTER])
const sepoliaPublicClient = await sepoliaNetwork.viem.getPublicClient()

console.log(`Receiver contract has been deployed to this address on the Sepolia testnet: ${receiver.address}`)
console.log(`View on Etherscan: https://sepolia.etherscan.io/address/${receiver.address}`)
console.log(`\nðŸ“‹ Copy the receiver address since it will be needed to run the verification script ðŸ“‹ \n`)

// Step 4: Send cross-chain message
console.log("\n[Step 4] Sending cross-chain message...")

const sendMessageTx = await sender.write.sendMessage([
  SEPOLIA_CHAIN_SELECTOR,
  receiver.address,
  "Hello World! cdnjkdjmdsd",
])

console.log("Cross-chain message sent, awaiting confirmation...")
console.log(`Message sent from source contract! âœ… \n Tx hash: ${sendMessageTx}`)
console.log(`View transaction status on CCIP Explorer: https://ccip.chain.link`)
console.log(
  "Run the receiver script after 10 minutes to check if the message has been received on the destination contract."
)
```

This script does the following:

- Connects to the Avalanche Fuji and Ethereum Sepolia networks.
- Deploys the sender contract on Avalanche Fuji.
- Funds the sender contract with 1 LINK.
- Deploys the receiver contract on Ethereum Sepolia.
- Sends a cross-chain message from the sender contract to the receiver contract.

3. Run the following command to send the cross-chain message:

```bash filename="terminal"
npx hardhat run scripts/send-cross-chain-message.ts
```

4. Wait for a few minutes for the message to be delivered to the receiver contract.
   Then create a new file named `verify-cross-chain-message.ts` in the `scripts` directory and paste the following code inside it:

<Callout type="note" title="Paste the Receiver contract address here">
  The second script will call the `getLastReceivedMessageDetails` function on the receiver contract to verify if the
  message has been received. It will need the correct address to call the function.
</Callout>

```typescript filename="scripts/verify-cross-chain-message.ts"
import { network } from "hardhat"

// Paste the Receiver contract address
const RECEIVER_ADDRESS = ""

console.log("Connecting to Ethereum Sepolia...")
const sepoliaNetwork = await network.connect("sepolia")

console.log("Checking for received message...\n")
const receiver = await sepoliaNetwork.viem.getContractAt("Receiver", RECEIVER_ADDRESS)

const [messageId, text] = await receiver.read.getLastReceivedMessageDetails()

// A null hexadecimal value means no message has been received yet
const ZERO_BYTES32 = "0x0000000000000000000000000000000000000000000000000000000000000000"

if (messageId === ZERO_BYTES32) {
  console.log("No message received yet.")
  console.log("Please wait a bit longer and try again.")
  process.exit(1)
} else {
  console.log(`âœ… Message ID: ${messageId}`)
  console.log(`Text: "${text}"`)
}
```

This script does the following:

- Connects to the Ethereum Sepolia network.
- Reads the last received message details from the receiver contract.
- Checks if any message has been received.
- Prints the message ID and text of the last received message.

5. Run the following command to verify the cross-chain message:

```bash filename="terminal"
npx hardhat run scripts/verify-cross-chain-message.ts
```

6. You should see the message ID and text of the last received message printed in the terminal.

  </Fragment>

  <Fragment slot="panel.2">

Foundry content will be added soon.

  </Fragment>
</Tabs>
