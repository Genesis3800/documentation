---
section: ccip
date: Last Modified
title: "Get Started with CCIP (EVM)"
metadata:
  description: "Get started with Chainlink CCIP on EVM chains. Deploy sender/receiver contracts, send data cross-chain, and pay fees in LINK."
  excerpt: "Chainlink CCIP, EVM chains, Ethereum, Avalanche, Cross-chain messaging, Solidity contracts, LINK token, Remix IDE, MetaMask, Testnet"
  datePublished: "2025-05-19"
  lastModified: "2025-12-25"
  estimatedTime: "20 minutes"
whatsnext:
  {
    "Learn how to transfer tokens": "/ccip/tutorials/evm/transfer-tokens-from-contract",
    "Learn how to transfer tokens and send data in a single CCIP transaction": "/ccip/tutorials/evm/programmable-token-transfers",
    "Transfer Tokens Between EOAs": "/ccip/tutorials/evm/offchain/transfer-tokens-from-eoa",
    "Learn how to send arbitrary data over CCIP": "/ccip/tutorials/evm/send-arbitrary-data",
    "CCIP Directory": "/ccip/directory",
  }
---

import { Callout } from "@components/Callout/Callout.tsx"
import { Accordion, CodeSample, ClickToZoom, CopyText, Aside } from "@components"
import CcipCommon from "@features/ccip/CcipCommon.astro"

<CcipCommon callout="talkToExpert" />

**Build and run a secure cross-chain messaging workflow between two EVM chains using Chainlink CCIP.**

In this guide, you will:

1. Deploy a sender on a source chain
2. Deploy a receiver on a destination chain
3. Send and verify a cross-chain message

## Before you begin

You will need:

- Basic [Solidity](https://soliditylang.org/) and [smart contract deployment](/quickstarts/deploy-your-first-contract) experience
- One [wallet](https://metamask.io/) funded on two CCIP-supported EVM testnets

- Choose one of the following development environments:
  - **[Hardhat](https://hardhat.org/docs/getting-started) (recommended)**
    Best for a **script-driven workflow** where you deploy contracts, send a CCIP message, and verify delivery from the command line. Ideal for getting a full end-to-end CCIP flow running quickly.

  - **[Foundry](https://book.getfoundry.sh/)**
    Best for **Solidity-native, test-driven workflows**, where CCIP messaging is validated through tests and assertions rather than scripts.

  - **[Remix](https://remix.ethereum.org/)**
    Suitable only for **quick, disposable demos**. Not recommended for testing, iteration, or production workflows.

## Examine the example code

<Accordion title="Sender code" number={1}>

The smart contract in this tutorial is designed to interact with CCIP to send data. The contract code includes comments to clarify the various functions, events, and underlying logic. However, this section explains the key elements. You can see the full contract code below.

<CodeSample src="samples/CCIP/Sender.sol" />

#### Initializing the contract

When deploying the contract, you define the router address and the LINK contract address of the blockchain where you choose to deploy the contract.

The router address provides functions that are required for this example:

- The `getFee` [function](/ccip/api-reference/evm/v1.6.1/i-router-client#getfee) to estimate the CCIP fees.
- The `ccipSend` [function](/ccip/api-reference/evm/v1.6.1/i-router-client#ccipsend) to send CCIP messages.

#### Sending data

The `sendMessage` function completes several operations:

1. Construct a CCIP-compatible message using the `EVM2AnyMessage` [struct](/ccip/api-reference/evm/v1.6.1/client#evm2anymessage):
   - The `receiver` address is encoded in bytes format to accommodate non-EVM destination blockchains with distinct address formats. The encoding is achieved through [abi.encode](https://docs.soliditylang.org/en/develop/abi-spec.html).
   - The `data` is encoded from a string text to bytes using [abi.encode](https://docs.soliditylang.org/en/develop/abi-spec.html).
   - The `tokenAmounts` is an array. Each element comprises a [struct](/ccip/api-reference/evm/v1.6.1/client#evmtokenamount) that contains the token address and amount. In this example, the array is empty because no tokens are sent.
   - The `extraArgs` specify the `gasLimit` for relaying the CCIP message to the recipient contract on the destination blockchain. In this example, the `gasLimit` is set to `200000`.
   - The `feeToken` designates the token address used for CCIP fees. Here, `address(linkToken)` signifies payment in LINK.

1. Compute the fees by invoking the router's `getFee` [function](/ccip/api-reference/evm/v1.6.1/i-router-client#getfee).
1. Ensure that your contract balance in LINK is enough to cover the fees.
1. Grant the router contract permission to deduct the fees from the contract's LINK balance.
1. Dispatch the CCIP message to the destination chain by executing the router's `ccipSend` [function](/ccip/api-reference/evm/v1.6.1/i-router-client#ccipsend).

<CcipCommon callout="senderContractCallout" />

</Accordion>

<Accordion title="Receiver code" number={2}>

The smart contract in this tutorial is designed to interact with CCIP to receive data. The contract code includes comments to clarify the various functions, events, and underlying logic. However, this section explains the key elements. You can see the full contract code below.

<CodeSample src="samples/CCIP/Receiver.sol" />

#### Initializing the contract

When you deploy the contract, you define the router address. The receiver contract inherits from the [CCIPReceiver.sol](/ccip/api-reference/evm/v1.6.1/ccip-receiver) contract, which uses the router address.

#### Receiving data

On the destination blockchain:

1. The CCIP Router invokes the `ccipReceive` [function](/ccip/api-reference/evm/v1.6.1/ccip-receiver#ccipreceive). **Note**: This function is protected by the `onlyRouter` [modifier](/ccip/api-reference/evm/v1.6.1/ccip-receiver#onlyrouter), which ensures that only the router can call the receiver contract.
1. The `ccipReceive` [function](/ccip/api-reference/evm/v1.6.1/ccip-receiver#ccipreceive) calls an internal function `_ccipReceive` [function](/ccip/api-reference/evm/v1.6.1/ccip-receiver#_ccipreceive). The receiver contract implements this function.
1. This `_ccipReceive` [function](/ccip/api-reference/evm/v1.6.1/ccip-receiver#_ccipreceive) expects an `Any2EVMMessage` [struct](/ccip/api-reference/evm/v1.6.1/client#any2evmmessage) that contains the following values:
   - The CCIP `messageId`.
   - The `sourceChainSelector`.
   - The `sender` address in bytes format. The sender is a contract deployed on an EVM-compatible blockchain, so the address is decoded from bytes to an Ethereum address using the [ABI specification](https://docs.soliditylang.org/en/v0.8.20/abi-spec.html).
   - The `data` is also in bytes format. A `string` is expected, so the data is decoded from bytes to a string using the [ABI specification](https://docs.soliditylang.org/en/v0.8.20/abi-spec.html).

<Aside type="caution" title="Recommendations Receiver contract">
The example was simplified for learning purposes. For production code, use the following best practices:

    - Validate the source chain.
    - Depending on your use case, analyze whether you should validate the sender address.

Note that the receiver contract in this example inherits from the base contract [CCIPReceiver.sol](/ccip/api-reference/evm/v1.6.1/ccip-receiver), which uses the `onlyRouter` [modifier](/ccip/api-reference/evm/v1.6.1/ccip-receiver#onlyrouter) to ensure that only the router can call the `ccipReceive` [function](/ccip/api-reference/evm/v1.6.1/ccip-receiver#ccipreceive).

</Aside>

</Accordion>

## Send a cross-chain message using CCIP

### Hardhat

<Accordion title="Bootstrap a new Hardhat project" number={1}>

1. Open a new terminal in a directory of your choice and run this command:

```bash filename="terminal"
npx hardhat --init
```

Create a project with the following options:

- Hardhat Version: hardhat-3
- Initialize project: At root of the project
- Type of project: A minimal Hardhat project
- Install the necessary dependencies: Yes

2. Install the additional dependencies required by this tutorial:

```bash filename="terminal"
npm install @chainlink/contracts-ccip @chainlink/contracts @openzeppelin/contracts viem dotenv
npm install --save-dev @nomicfoundation/hardhat-viem
```

<Callout type="danger" title="PLEASE DON'T USE PRIVATE KEYS WITH MAINNET FUNDS">
  Private keys stored in `.env` files have been compromised and accidently pushed online before. Please be VERY CAREFUL
  while choosing which private key to use for this tutorial.
</Callout>

3. Create a `.env` file with the following variables:

```env filename=".env"
PRIVATE_KEY=0x.....
SEPOLIA_RPC_URL=https.....
FUJI_RPC_URL=https.....
```

4. Update `hardhat.config.ts` to use your environment variables and the `hardhat-viem` plugin:

```typescript filename="hardhat.config.ts"
import "dotenv/config"
import { configVariable, defineConfig } from "hardhat/config"
import hardhatViem from "@nomicfoundation/hardhat-viem"

export default defineConfig({
  plugins: [hardhatViem],
  solidity: {
    version: "0.8.24",
  },
  networks: {
    sepolia: {
      type: "http",
      url: configVariable("SEPOLIA_RPC_URL"),
      accounts: [configVariable("PRIVATE_KEY")],
    },
    avalancheFuji: {
      type: "http",
      url: configVariable("FUJI_RPC_URL"),
      accounts: [configVariable("PRIVATE_KEY")],
    },
  },
})
```

</Accordion>

<Accordion title="Set up the contracts" number={2}>

1. Create a new directory named `contracts` for your smart contracts if it doesn't already exist.
2. Create a new file named `Sender.sol` in this directory and paste the sender contract code inside it.
3. Create a new file named `Receiver.sol` in the same directory and paste the receiver contract code inside it.
4. Create a `contracts/interfaces` directory and create a new file named `IERC20.sol` inside it. Our script will need to make a call to the `LINK ERC-20` contract to transfer LINK to the sender contract.
   It will need access to an ERC-20 interface to be able to call the `transfer` function.
5. Paste the following code into the `IERC20.sol` file:

```solidity filename="contracts/interfaces/IERC20.sol"
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

// Re-export OpenZeppelin's IERC20 interface
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";

interface IERC20Extended is IERC20 {}
```

6. Run the following command to compile the contracts:

```bash filename="terminal"
npx hardhat build
```

</Accordion>

<Accordion title="Send a cross-chain message using CCIP" number={3}>

1. Create a new directory named `scripts` at the root of the project if it doesn't already exist.
2. Create a new file named `send-cross-chain-message.ts` in this directory and paste the following code inside it:

```typescript filename="scripts/send-cross-chain-message.ts"
import { network } from "hardhat"
import { parseUnits } from "viem"

// Avalanche Fuji configuration
const FUJI_ROUTER = "0xF694E193200268f9a4868e4Aa017A0118C9a8177"
const FUJI_LINK = "0x0b9d5D9136855f6FEc3c0993feE6E9CE8a297846"

// Ethereum Sepolia configuration
// Note that the contract on Sepolia doesn't need to have LINK to pay for CCIP fees.
const SEPOLIA_ROUTER = "0x0BF3dE8c5D3e8A2B34D2BEeB17ABfCeBaf363A59"
const SEPOLIA_CHAIN_SELECTOR = 16015286601757825753n

// Connect to Avalanche Fuji
console.log("Connecting to Avalanche Fuji...")
const fujiNetwork = await network.connect("avalancheFuji")

// Connect to Ethereum Sepolia
console.log("Connecting to Ethereum Sepolia...")
const sepoliaNetwork = await network.connect("sepolia")

// Step 1: Deploy Sender on Fuji
console.log("\n[Step 1] Deploying Sender contract on Avalanche Fuji...")

const sender = await fujiNetwork.viem.deployContract("Sender", [FUJI_ROUTER, FUJI_LINK])
const fujiPublicClient = await fujiNetwork.viem.getPublicClient()

console.log(`Sender contract has been deployed to this address on the Fuji testnet: ${sender.address}`)
console.log(`View on Avascan: https://testnet.avascan.info/blockchain/all/address/${sender.address}`)

// Step 2: Fund Sender with LINK
console.log("\n[Step 2] Funding Sender with 1 LINK...")

const fujiLinkToken = await fujiNetwork.viem.getContractAt("IERC20Extended", FUJI_LINK)

const transferLinkToFujiContract = await fujiLinkToken.write.transfer([sender.address, parseUnits("1", 18)])

console.log("LINK token transfer in progress, awaiting confirmation...")
await fujiPublicClient.waitForTransactionReceipt({ hash: transferLinkToFujiContract, confirmations: 1 })
console.log(`Funded Sender with 1 LINK`)

// Step 3: Deploy Receiver on Sepolia
console.log("\n[Step 3] Deploying Receiver on Ethereum Sepolia...")

const receiver = await sepoliaNetwork.viem.deployContract("Receiver", [SEPOLIA_ROUTER])
const sepoliaPublicClient = await sepoliaNetwork.viem.getPublicClient()

console.log(`Receiver contract has been deployed to this address on the Sepolia testnet: ${receiver.address}`)
console.log(`View on Etherscan: https://sepolia.etherscan.io/address/${receiver.address}`)
console.log(`\nðŸ“‹ Copy the receiver address since it will be needed to run the verification script ðŸ“‹ \n`)

// Step 4: Send cross-chain message
console.log("\n[Step 4] Sending cross-chain message...")

const sendMessageTx = await sender.write.sendMessage([
  SEPOLIA_CHAIN_SELECTOR,
  receiver.address,
  "Hello World! cdnjkdjmdsd",
])

console.log("Cross-chain message sent, awaiting confirmation...")
console.log(`Message sent from source contract! âœ… \n Tx hash: ${sendMessageTx}`)
console.log(`View transaction status on CCIP Explorer: https://ccip.chain.link`)
console.log(
  "Run the receiver script after 10 minutes to check if the message has been received on the destination contract."
)
```

This script does the following:

- Connects to the Avalanche Fuji and Ethereum Sepolia networks.
- Deploys the sender contract on Avalanche Fuji.
- Funds the sender contract with 1 LINK.
- Deploys the receiver contract on Ethereum Sepolia.
- Sends a cross-chain message from the sender contract to the receiver contract.

3. Run the following command to send the cross-chain message:

```bash filename="terminal"
npx hardhat run scripts/send-cross-chain-message.ts
```

4. Wait for a few minutes for the message to be delivered to the receiver contract.
   Then create a new file named `verify-cross-chain-message.ts` in the `scripts` directory and paste the following code inside it:

<Callout type="note" title="Paste the Receiver contract address here">
  The second script will call the `getLastReceivedMessageDetails` function on the receiver contract to verify if the
  message has been received. It will need the correct address to call the function.
</Callout>

```typescript filename="scripts/verify-cross-chain-message.ts"
import { network } from "hardhat"

// Paste the Receiver contract address
const RECEIVER_ADDRESS = ""

console.log("Connecting to Ethereum Sepolia...")
const sepoliaNetwork = await network.connect("sepolia")

console.log("Checking for received message...\n")
const receiver = await sepoliaNetwork.viem.getContractAt("Receiver", RECEIVER_ADDRESS)

const [messageId, text] = await receiver.read.getLastReceivedMessageDetails()

// A null hexadecimal value means no message has been received yet
const ZERO_BYTES32 = "0x0000000000000000000000000000000000000000000000000000000000000000"

if (messageId === ZERO_BYTES32) {
  console.log("No message received yet.")
  console.log("Please wait a bit longer and try again.")
  process.exit(1)
} else {
  console.log(`âœ… Message ID: ${messageId}`)
  console.log(`Text: "${text}"`)
}
```

This script does the following:

- Connects to the Ethereum Sepolia network.
- Reads the last received message details from the receiver contract.
- Checks if any message has been received.
- Prints the message ID and text of the last received message.

5. Run the following command to verify the cross-chain message:

```bash filename="terminal"
npx hardhat run scripts/verify-cross-chain-message.ts
```

6. You should see the message ID and text of the last received message printed in the terminal.

</Accordion>

### Foundry

Foundry content coming soon...
